/*
A retry mechanism is application logic designed to automatically re-attempt a failed API request. This is crucial for handling transient (temporary) failures that are expected to resolve themselves quickly, such as momentary network outages, temporary server load spikes, or connection timeouts.

ðŸ’¡ Core Components
Identify Retryable Errors: Only attempt retries for errors that are transient, typically:

503 Service Unavailable or 504 Gateway Timeout.

Network errors (e.g., connection lost).

429 Too Many Requests (if combined with a backoff strategy).

DO NOT retry for permanent errors like 404 Not Found or 400 Bad Request.

Limit Attempts: Always set a maximum number of retries (e.g., 3 to 5) to prevent infinite loops and resource waste.

Backoff Strategy: Implement a delay between retries, often using Exponential Backoff (see next section) to avoid immediately overwhelming the server.




*/


// script.js

const API_URL = 'https://api.example.com/data/unstable'; // Conceptual URL
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000; // 1 second delay

// Utility function to introduce a pause
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchWithRetry(url, attempt = 1) {
    console.log(`\nAttempting to fetch data (Attempt ${attempt}/${MAX_RETRIES})...`);

    try {
        const response = await axios.get(url);
        
        // Success
        console.log(`âœ… Success! Status: ${response.status}`);
        return response.data;

    } catch (error) {
        const status = error.response ? error.response.status : 'Network Error';
        
        // 1. Check if the error is retryable and if we have attempts left
        const isTransientError = (status === 503 || status === 504 || status === 429 || status === 'Network Error');
        
        if (attempt < MAX_RETRIES && isTransientError) {
            console.warn(`âš ï¸ Attempt failed (Status: ${status}). Retrying in ${RETRY_DELAY_MS / 1000}s...`);
            
            // 2. Introduce a delay (Backoff)
            await sleep(RETRY_DELAY_MS);
            
            // 3. Re-attempt the request
            return fetchWithRetry(url, attempt + 1);
        }

        // 4. Final Failure: If all retries are exhausted or it's a non-retryable error
        console.error(`\nðŸ›‘ Final failure after ${attempt} attempts. Status: ${status}`);
        throw new Error(`API failed after all retries. Status: ${status}`);
    }
}

// NOTE: This requires a real API that simulates transient failures (e.g., returning 503 sometimes).
fetchWithRetry(API_URL);
