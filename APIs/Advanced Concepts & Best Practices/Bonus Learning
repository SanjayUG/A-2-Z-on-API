/*
Bonus Learning: Advanced API Architectures
For developers ready to move beyond basic REST, these technologies represent the next level in API design, offering better performance, efficiency, or real-time capabilities.

1. Webhooks (Push Communication) ðŸŽ£
Webhooks are a mechanism for an API to send real-time, automated messages (or payloads) to a client when a specific event occurs, instead of the client continuously asking the server for updates (polling).

How it works: The client provides the server with a unique URL (the "hook"). When an event happens (e.g., a payment is completed), the server makes an immediate POST request to that URL.

Analogy: Instead of calling a restaurant every 5 minutes to ask if your food is ready (polling), the restaurant texts you the moment it's done (webhook).

2. WebSockets (Bidirectional Real-Time) âš¡
WebSockets provide a persistent, two-way communication channel between a client and a server over a single, long-lived TCP connection. This enables true real-time data exchange.

How it works: Communication starts with an HTTP handshake (ws:// or wss://), which upgrades the connection to a WebSocket. Once established, both the client and server can send data to each other simultaneously and instantly.


Best Used For: Chat applications, live sports tickers, collaborative editing tools, and anything requiring low-latency, frequent updates.

3. GraphQL (Data Efficiency) ðŸ“Š
GraphQL is a query language for your API and a server-side runtime for executing those queries. It was developed by Facebook as an alternative to REST.


Core Feature: Clients ask for exactly what they need, nothing more, nothing less.

Problem it Solves: Over-fetching (getting more data than you need) and Under-fetching (needing multiple REST endpoints for related data). With GraphQL, you make one request to one endpoint (/graphql) and specify all required fields.

4. gRPC (High Performance) ðŸš€
gRPC (gRPC Remote Procedure Call) is a modern, high-performance framework developed by Google. It is primarily used for communication between internal services (microservices) but can be used externally.

Core Feature: Uses Protocol Buffers (Protobuf) for data serialization (instead of JSON), which are much smaller and faster to serialize/deserialize. It relies on HTTP/2 for transport.

Benefit: Significantly lower latency and higher throughput compared to REST/JSON APIs, making it ideal for systems where speed is critical.



*/
